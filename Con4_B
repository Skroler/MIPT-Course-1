#include <iostream>
#include <vector>

class FenTree{
private:
    int n;
    std::vector<long long> t;
    void init (int nn)
    {
        n = nn;
        t.assign (n, 0);
    }

public:
    long long sum (int pos)
    {
        long long result = 0;
        for (; pos >= 0; pos = (pos & (pos+1)) - 1)
            result += t[pos];
        return result;
    }

    void init (std::vector<int> a)
    {
        init ((int) a.size());
        for (unsigned i = 0; i < a.size(); ++i)
            inc (i, a[i]);
    }

    long long spsum(int l, int r){
        return (sum(r) - sum(l-1));
    };

    void inc (int i, long long delta)
    {
        for (; i < n; i = (i | (i+1)))
            t[i] += delta;
    }
};

int main(){
    FenTree tree;
    FenTree tree_imp;
    long long r;
    int n, m, id, l, temp;
    std::cin >> n;
    std::vector<int> a(n+2);
    std::vector<int> b(n+2);
    for (int i = 0; i < n; ++i){
        std::cin >> temp;
        if (i % 2 == 0) {
            a[i] = temp;
            b[i] = -temp;
        }
        else {
            a[i] = -temp;
            b[i] = temp;
        }
    }

    tree.init(a);
    tree_imp.init(b);

    //std::cout << "tree = " << tree.sum(a.size() - 1) << '\n';
    //std::cout << "tree_imp = " << tree_imp.sum(a.size()-1) << '\n';

    std::cin >> m;
    for (int i = 0; i < m; ++i){
        std::cin >> id;
        std::cin >> l;
        std::cin >> r;
        if (id == 0) {
            if ((l - 1) % 2 == 1) {
                tree.inc(l - 1, -r - a[l - 1]);
                tree_imp.inc(l - 1, r - b[l - 1]);
                //std::cout << "tree = " << tree.sum(a.size() - 1) << '\n';
                //std::cout << "tree_imp = " << tree_imp.sum(a.size()-1) << '\n';
                a[l-1] = -r;
                b[l-1] = r;
            } else {
                tree.inc(l - 1, r - a[l - 1]);
                tree_imp.inc(l - 1, -r - b[l - 1]);
                //std::cout << "tree = " << tree.sum(a.size() - 1) << '\n';
                //std::cout << "tree_imp = " << tree_imp.sum(a.size()-1) << '\n';
                a[l-1] = r;
                b[l-1] = -r;
            }
        }
        else {
            if (l % 2 == 0) {
                std::cout << tree_imp.spsum(l - 1, r - 1) << '\n';
            } else {
                std::cout << tree.spsum(l - 1, r - 1) << '\n';
            }
            //std::cout << tree.spsum(l-1, r-1) << '\n';
            //std::cout<<"f1" << '\n';
        }
    }

    //std::cout << tree.sum(a.size()-1);
}




//Реализуйте структуру данных из 𝑛 элементов 𝑎1,𝑎2…𝑎𝑛, поддерживающую следующие операции:
//присвоить элементу 𝑎𝑖 значение 𝑗;
//найти знакочередующуюся сумму на отрезке от 𝑙 до 𝑟 включительно (𝑎𝑙−𝑎𝑙+1+𝑎𝑙+2−…±𝑎𝑟).
// В последующих 𝑚 строках записаны операции:
//операция первого типа задается тремя числами 0 i j (1≤𝑖≤𝑛, 1≤𝑗≤104).
//операция второго типа задается тремя числами 1 l r (1≤𝑙≤𝑟≤𝑛).
//
